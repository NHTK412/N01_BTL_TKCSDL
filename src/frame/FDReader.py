# main.py
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, Menu
from data_structures.functional_dependency import FD
from util.util import util

import os

class FDReader(tk.Frame):
   
    
    def __init__(self, parent):
        super().__init__(parent)
        self.fd_set1 = []
        self.fd_set2 = []
        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(0, weight=1)

        self.create_widgets()
        
   
    def create_widgets(self):
        """T·∫°o c√°c widget"""
        # Header Frame
        header_frame = tk.Frame(self, bg='#2c3e50', height=80)
        header_frame.grid(row=0, 
                          column=0, 
                          columnspan=3, 
                          sticky="ew", 
                          padx=10, 
                          pady=(10, 0))
        
        header_frame.grid_propagate(False)
        
        title_label = tk.Label(
            header_frame,
            text="üîç KI·ªÇM TRA T∆Ø∆†NG ƒê∆Ø∆†NG HAI T·∫¨P PH·ª§ THU·ªòC H√ÄM",
            font=('Arial', 18, 'bold'),
            fg='white',
            bg='#2c3e50'
        )
        title_label.pack(expand=True)
        
        # Content Frame
        content_frame = tk.Frame(self, bg='#f0f0f0')
        content_frame.grid(row=1, 
                           column=0, 
                           columnspan=3, 
                           sticky="nsew", 
                           padx=10, 
                           pady=10)
        content_frame.columnconfigure(0, weight=1)
        content_frame.columnconfigure(1, weight=1)
        content_frame.columnconfigure(2, weight=1)
        content_frame.rowconfigure(1, weight=1)
        
        # Control Panel
        control_frame = tk.Frame(content_frame, bg='#f0f0f0', height=100)
        control_frame.grid(row=0, 
                           column=0, 
                           columnspan=3, 
                           sticky="ew", 
                           pady=(0, 10))
        control_frame.grid_propagate(False)
        
        # Style cho button
        style = ttk.Style()
        style.configure(
            'Custom.TButton',
            font=('Arial', 11, 'bold'),
            padding=(15, 8)
        )
        
        # Frame cho file 1
        file1_frame = tk.Frame(control_frame, bg='#f0f0f0')
        file1_frame.pack(side=tk.LEFT, padx=20, pady=10, fill='y')
        
        self.open_button1 = ttk.Button(
            file1_frame,
            text="üìÇ Ch·ªçn File T·∫≠p 1",
            style='Custom.TButton',
            command=lambda: self.open_file(1)
        )
        self.open_button1.pack(pady=(0, 5))
        
        self.file_label1 = tk.Label(
            file1_frame,
            text="Ch∆∞a ch·ªçn file t·∫≠p 1",
            font=('Arial', 9),
            fg='#7f8c8d',
            bg='#f0f0f0'
        )
        self.file_label1.pack()
        
        # Frame cho file 2
        file2_frame = tk.Frame(control_frame, bg='#f0f0f0')
        file2_frame.pack(side=tk.LEFT, padx=20, pady=10, fill='y')
        
        self.open_button2 = ttk.Button(
            file2_frame,
            text="üìÇ Ch·ªçn File T·∫≠p 2",
            style='Custom.TButton',
            command=lambda: self.open_file(2)
        )
        self.open_button2.pack(pady=(0, 5))
        
        self.file_label2 = tk.Label(
            file2_frame,
            text="Ch∆∞a ch·ªçn file t·∫≠p 2",
            font=('Arial', 9),
            fg='#7f8c8d',
            bg='#f0f0f0'
        )
        self.file_label2.pack()
        
        # Button ki·ªÉm tra t∆∞∆°ng ƒë∆∞∆°ng (ƒë·∫∑t ·ªü gi·ªØa)
        check_frame = tk.Frame(control_frame, bg='#f0f0f0')
        check_frame.pack(expand=True, fill='both')
        
        self.check_equiv_button = ttk.Button(
            check_frame,
            text="üîç Ki·ªÉm Tra T∆∞∆°ng ƒê∆∞∆°ng",
            style='Custom.TButton',
            command=self.check_equivalence,
            state='disabled'
        )
        self.check_equiv_button.pack(expand=True, pady=20)
        
        # Label th·ªëng k√™
        self.stats_label = tk.Label(
            control_frame,
            text="",
            font=('Arial', 10, 'bold'),
            fg='#27ae60',
            bg='#f0f0f0'
        )
        self.stats_label.pack(side=tk.RIGHT, padx=20, pady=10)
        
        # Left Panel - T·∫≠p FD 1
        left_frame = tk.LabelFrame(
            content_frame,
            text="üìù T·∫≠p Ph·ª• Thu·ªôc H√†m 1",
            font=('Arial', 11, 'bold'),
            fg='#34495e',
            bg='#f0f0f0',
            padx=10,
            pady=10
        )
        left_frame.grid(row=1, 
                        column=0, 
                        sticky="nsew", 
                        padx=(0, 5))
        left_frame.columnconfigure(0, weight=1)
        left_frame.rowconfigure(0, weight=1)
        
        # Text area cho t·∫≠p FD 1
        self.fd1_text = tk.Text(
            left_frame,
            font=('Consolas', 10),
            wrap=tk.WORD,
            bg='#f8f9fa',
            relief=tk.FLAT,
            bd=1,
            padx=10,
            pady=10,
            state=tk.DISABLED
        )
        self.fd1_text.grid(row=0, column=0, sticky="nsew")
        
        # Scrollbar cho fd1
        fd1_scroll = ttk.Scrollbar(left_frame, command=self.fd1_text.yview)
        fd1_scroll.grid(row=0, column=1, sticky="ns")
        self.fd1_text.config(yscrollcommand=fd1_scroll.set)
        
        # Middle Panel - T·∫≠p FD 2
        middle_frame = tk.LabelFrame(
            content_frame,
            text="üìù T·∫≠p Ph·ª• Thu·ªôc H√†m 2",
            font=('Arial', 11, 'bold'),
            fg='#34495e',
            bg='#f0f0f0',
            padx=10,
            pady=10
        )
        middle_frame.grid(row=1, column=1, sticky="nsew", padx=(2.5, 2.5))
        middle_frame.columnconfigure(0, weight=1)
        middle_frame.rowconfigure(0, weight=1)
        
        # Text area cho t·∫≠p FD 2
        self.fd2_text = tk.Text(
            middle_frame,
            font=('Consolas', 10),
            wrap=tk.WORD,
            bg='#f8f9fa',
            relief=tk.FLAT,
            bd=1,
            padx=10,
            pady=10,
            state=tk.DISABLED
        )
        self.fd2_text.grid(row=0, column=0, sticky="nsew")
        
        # Scrollbar cho fd2
        fd2_scroll = ttk.Scrollbar(middle_frame, command=self.fd2_text.yview)
        fd2_scroll.grid(row=0, column=1, sticky="ns")
        self.fd2_text.config(yscrollcommand=fd2_scroll.set)
        
        # Right Panel - K·∫øt qu·∫£ ki·ªÉm tra
        right_frame = tk.LabelFrame(
            content_frame,
            text="üîç K·∫øt Qu·∫£ Ki·ªÉm Tra T∆∞∆°ng ƒê∆∞∆°ng",
            font=('Arial', 11, 'bold'),
            fg='#34495e',
            bg='#f0f0f0',
            padx=10,
            pady=10
        )
        right_frame.grid(row=1, column=2, sticky="nsew", padx=(5, 0))
        right_frame.columnconfigure(0, weight=1)
        right_frame.rowconfigure(0, weight=1)
        
        # Text area cho k·∫øt qu·∫£
        self.result_text = tk.Text(
            right_frame,
            font=('Consolas', 10),
            wrap=tk.WORD,
            bg='#e8f5e8',
            relief=tk.FLAT,
            bd=1,
            padx=10,
            pady=10,
            state=tk.DISABLED
        )
        self.result_text.grid(row=0, column=0, sticky="nsew")
        
        # Scrollbar cho result
        result_scroll = ttk.Scrollbar(right_frame, command=self.result_text.yview)
        result_scroll.grid(row=0, column=1, sticky="ns")
        self.result_text.config(yscrollcommand=result_scroll.set)
        
    def open_file(self, file_number):
        """M·ªü v√† ƒë·ªçc file"""
        file_path = filedialog.askopenfilename(
            title=f"Ch·ªçn file t·∫≠p ph·ª• thu·ªôc h√†m {file_number}",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if not file_path:
            return
            
        try:
            filename = file_path.split('/')[-1]
            
            # X√≥a n·ªôi dung c≈©
            if file_number == 1:
                self.file_label1.config(text=f"üìÑ {filename}", fg='#2c3e50')
                self.fd1_text.config(state=tk.NORMAL)
                self.fd1_text.delete(1.0, tk.END)
                self.fd_set1.clear()
                fd_list = self.fd_set1
                text_widget = self.fd1_text
            else:
                self.file_label2.config(text=f"üìÑ {filename}", fg='#2c3e50')
                self.fd2_text.config(state=tk.NORMAL)
                self.fd2_text.delete(1.0, tk.END)
                self.fd_set2.clear()
                fd_list = self.fd_set2
                text_widget = self.fd2_text
            
            # ƒê·ªçc file
            with open(file_path, 'r', encoding='utf-8') as file:
                file_data = file.read()
            
            file_data = file_data.split('\n')
            fd_count = 0

            for line in file_data:
                line = line.strip()
                if not line:
                    continue
                
                # Ph√¢n t√≠ch ph·ª• thu·ªôc h√†m
                fd = util.parse_fd_line(line)
                if fd:
                    fd_list.append(fd)
                    fd_count += 1
                    text_widget.insert(tk.END, f"FD{fd_count}: {fd}\n")

            text_widget.config(state=tk.DISABLED)
            
            # C·∫≠p nh·∫≠t tr·∫°ng th√°i button
            if self.fd_set1 and self.fd_set2:
                self.check_equiv_button.config(state='normal')
            
            # C·∫≠p nh·∫≠t th·ªëng k√™
            self.update_stats()
            
            messagebox.showinfo("Th√†nh c√¥ng", f"ƒê√£ ƒë·ªçc {fd_count} ph·ª• thu·ªôc h√†m t·ª´ t·∫≠p {file_number}!")
            
        except Exception as e:
            messagebox.showerror("L·ªói", f"Kh√¥ng th·ªÉ ƒë·ªçc file: {str(e)}")
            
    
    
    def update_stats(self):
        """C·∫≠p nh·∫≠t th·ªëng k√™"""
        stats_text = f"T·∫≠p 1: {len(self.fd_set1)} FD"
        if self.fd_set2:
            stats_text += f" | T·∫≠p 2: {len(self.fd_set2)} FD"
        self.stats_label.config(text=stats_text)
    
    def check_equivalence(self):
        """Ki·ªÉm tra t∆∞∆°ng ƒë∆∞∆°ng hai t·∫≠p FD"""
        if not self.fd_set1 or not self.fd_set2:
            messagebox.showwarning("C·∫£nh b√°o", "Vui l√≤ng ch·ªçn c·∫£ hai file tr∆∞·ªõc!")
            return
        
        self.result_text.config(state=tk.NORMAL)
        self.result_text.delete(1.0, tk.END)
        
        self.result_text.insert(tk.END, "KI·ªÇM TRA T∆Ø∆†NG ƒê∆Ø∆†NG HAI T·∫¨P PH·ª§ THU·ªòC H√ÄM\n")
        self.result_text.insert(tk.END, "=" * 46 + "\n\n")
        
        # B∆∞·ªõc 1: Ki·ªÉm tra F1 ‚ä¢ F2
        self.result_text.insert(tk.END, "B∆Ø·ªöC 1: Ki·ªÉm tra T·∫≠p 1 c√≥ suy di·ªÖn ra T·∫≠p 2 kh√¥ng?\n")
        self.result_text.insert(tk.END, "-" * 46 + "\n")
        
        f1_implies_f2, f1_f2_details = self.check_implication(self.fd_set1, self.fd_set2, "T·∫≠p 1", "T·∫≠p 2")
        
        self.result_text.insert(tk.END, f1_f2_details)
        self.result_text.insert(tk.END, f"\nK·∫øt qu·∫£ B∆∞·ªõc 1: {'‚úÖ T·∫≠p 1 suy di·ªÖn ra T·∫≠p 2' if f1_implies_f2 else '‚ùå T·∫≠p 1 KH√îNG suy di·ªÖn ra T·∫≠p 2'}\n\n")
        
        # B∆∞·ªõc 2: Ki·ªÉm tra F2 ‚ä¢ F1
        self.result_text.insert(tk.END, "B∆Ø·ªöC 2: Ki·ªÉm tra T·∫≠p 2 c√≥ suy di·ªÖn ra T·∫≠p 1 kh√¥ng?\n")
        self.result_text.insert(tk.END, "-" * 46 + "\n")
        
        f2_implies_f1, f2_f1_details = self.check_implication(self.fd_set2, self.fd_set1, "T·∫≠p 2", "T·∫≠p 1")
        
        self.result_text.insert(tk.END, f2_f1_details)
        self.result_text.insert(tk.END, f"\nK·∫øt qu·∫£ B∆∞·ªõc 2: {'‚úÖ T·∫≠p 2 suy di·ªÖn ra T·∫≠p 1' if f2_implies_f1 else '‚ùå T·∫≠p 2 KH√îNG suy di·ªÖn ra T·∫≠p 1'}\n\n")
        
        # B∆∞·ªõc 3: K·∫øt lu·∫≠n
        self.result_text.insert(tk.END, "B∆Ø·ªöC 3: K·∫æT LU·∫¨N\n")
        self.result_text.insert(tk.END, "=" * 20 + "\n")
        
        if f1_implies_f2 and f2_implies_f1:
            self.result_text.insert(tk.END, "‚úÖ HAI T·∫¨P PH·ª§ THU·ªòC H√ÄM T∆Ø∆†NG ƒê∆Ø∆†NG!\n")
            self.result_text.insert(tk.END, "L√Ω do: T·∫≠p 1 ‚ä¢ T·∫≠p 2 V√Ä T·∫≠p 2 ‚ä¢ T·∫≠p 1\n")
        else:
            self.result_text.insert(tk.END, "‚ùå HAI T·∫¨P PH·ª§ THU·ªòC H√ÄM KH√îNG T∆Ø∆†NG ƒê∆Ø∆†NG!\n")
            if not f1_implies_f2 and not f2_implies_f1:
                self.result_text.insert(tk.END, "L√Ω do: T·∫≠p 1 kh√¥ng suy di·ªÖn ra T·∫≠p 2 V√Ä T·∫≠p 2 kh√¥ng suy di·ªÖn ra T·∫≠p 1\n")
            elif not f1_implies_f2:
                self.result_text.insert(tk.END, "L√Ω do: T·∫≠p 1 kh√¥ng suy di·ªÖn ra T·∫≠p 2\n")
            else:
                self.result_text.insert(tk.END, "L√Ω do: T·∫≠p 2 kh√¥ng suy di·ªÖn ra T·∫≠p 1\n")
        
        self.result_text.config(state=tk.DISABLED)
    
    def check_implication(self, from_set, to_set, from_name, to_name):
        """Ki·ªÉm tra xem from_set c√≥ suy di·ªÖn ra to_set kh√¥ng"""
        details = ""
        all_implied = True
        failed_fds = []
        
        for i, fd in enumerate(to_set, 1):
            lhs = fd.getLhs()
            rhs = fd.getRhs()
            
            # T√≠nh bao ƒë√≥ng c·ªßa LHS s·ª≠ d·ª•ng from_set
            closure, steps = self.compute_closure_with_set(lhs, from_set)
            
            # Ki·ªÉm tra xem RHS c√≥ n·∫±m trong bao ƒë√≥ng kh√¥ng
            is_implied = rhs.issubset(closure)
            
            lhs_str = ''.join(sorted(lhs))
            rhs_str = ''.join(sorted(rhs))
            closure_str = ''.join(sorted(closure))
            
            details += f"Ki·ªÉm tra FD{i}: {lhs_str} ‚Üí {rhs_str}\n"
            details += f"({lhs_str})‚Å∫ theo {from_name} = {{{closure_str}}}\n"
            
            if is_implied:
                details += f"‚úÖ {rhs_str} ‚äÜ {{{closure_str}}} ‚Üí FD{i} ƒë∆∞·ª£c suy di·ªÖn\n\n"
            else:
                details += f"‚ùå {rhs_str} ‚äÑ {{{closure_str}}} ‚Üí FD{i} KH√îNG ƒë∆∞·ª£c suy di·ªÖn\n\n"
                all_implied = False
                failed_fds.append(f"FD{i}")
        
        return all_implied, details
    
    def compute_closure_with_set(self, attributes, fd_set):
        """T√≠nh to√°n bao ƒë√≥ng v·ªõi t·∫≠p FD cho tr∆∞·ªõc"""
        closure = attributes.copy()
        steps = []
        changed = True
        
        while changed:
            changed = False
            applied_fds = []
            
            for fd in fd_set:
                # Ki·ªÉm tra n·∫øu LHS c·ªßa FD n·∫±m trong closure hi·ªán t·∫°i
                if fd.getLhs().issubset(closure):
                    # Th√™m RHS v√†o closure
                    before_size = len(closure)
                    closure = closure.union(fd.getRhs())
                    
                    # N·∫øu c√≥ thu·ªôc t√≠nh m·ªõi ƒë∆∞·ª£c th√™m v√†o
                    if len(closure) > before_size:
                        applied_fds.append(fd)
                        changed = True
            
            # L∆∞u b∆∞·ªõc n·∫øu c√≥ thay ƒë·ªïi
            if changed:
                steps.append((closure.copy(), applied_fds))
        
        return closure, steps
    
   